<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Concrete Pad Heating Calculator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
  <div id="root"></div>
  <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script>
  <script type="text/babel">
    // Defining material properties reference
    const materialProperties = [
      { name: 'Sand 5mm', weight: 105, specificHeat: 0.198, key: 'sand' },
      { name: '19mm Stone', weight: 110, specificHeat: 0.208, key: 'stone19mm' },
      { name: '10mm Stone', weight: 105, specificHeat: 0.202, key: 'stone10mm' },
      { name: 'Limestone', weight: 165, specificHeat: 0.217, key: 'limestone' }
    ];

    // Steam generator properties reference
    const steamGenerators = [
      { name: 'ST102', btu: 800000 },
      { name: 'ST302', btu: 2400000 },
      { name: 'ST502', btu: 4000000 },
      { name: 'ST602', btu: 6000000 }
    ];

    // Conversion factors
    const CUBIC_FEET_TO_CUBIC_METERS = 0.0283168;
    const FEET_TO_METERS = 0.3048;
    const METERS_TO_FEET = 3.28084;
    const LB_PER_CUFT_TO_KG_PER_CUM = 16.0185;
    const BTU_PER_HR_TO_KW = 0.000293071;
    const BTU_PER_LB_F_TO_KJ_PER_KG_C = 4.1868;

    // Temperature conversion functions
    const fahrenheitToCelsius = (f) => isNaN(f) ? 0 : ((f - 32) * 5 / 9).toFixed(2);
    const celsiusToFahrenheit = (c) => isNaN(c) ? 0 : ((c * 9 / 5) + 32).toFixed(2);

    // Tooltip component
    const Tooltip = ({ text }) => {
      const [isVisible, setIsVisible] = React.useState(false);
      return (
        <div className="relative inline-block ml-2">
          <span
            className="inline-flex items-center justify-center w-4 h-4 text-xs font-semibold text-white bg-gray-500 rounded-full cursor-pointer"
            onMouseEnter={() => setIsVisible(true)}
            onMouseLeave={() => setIsVisible(false)}
          >
            ?
          </span>
          {isVisible && (
            <div className="absolute z-10 w-64 p-2 text-xs text-gray-700 bg-white border border-gray-300 rounded shadow-lg -top-2 left-6">
              {text}
            </div>
          )}
        </div>
      );
    };

    // Initializing React component
    const PadHeatingCalculator = () => {
      // Defining state for inputs and unit system
      const [unitSystem, setUnitSystem] = React.useState('imperial'); // imperial or metric
      const [inputs, setInputs] = React.useState({
        length: 30, // ft or m
        width: 30,
        height: 8,
        sandInletTemp: 14, // °F or °C
        sandDischargeTemp: 118.4,
        stoneInletTemp: 14,
        stoneDischargeTemp: 50,
        customer: '' // New customer field
      });
      const [results, setResults] = React.useState(null);
      const [errors, setErrors] = React.useState({});

      // Validating input
      const validateInput = (name, value) => {
        if (name === 'customer') return ''; // No validation for customer field
        if (value === '' || isNaN(value)) {
          return `${name} must be a number`;
        }
        // Only validate non-negative for dimensions
        if (['length', 'width', 'height'].includes(name) && value < 0) {
          return `${name} must be non-negative`;
        }
        return '';
      };

      // Handling input change
      const handleInputChange = (e) => {
        const { name, value } = e.target;
        const parsedValue = name === 'customer' ? value : (value === '' ? '' : parseFloat(value));
        setInputs({ ...inputs, [name]: parsedValue });

        // Validating input on change
        const error = validateInput(name, parsedValue);
        setErrors({ ...errors, [name]: error });
      };

      // Handling unit system change
      const handleUnitSystemChange = (newUnitSystem) => {
        if (newUnitSystem === unitSystem) return;

        const newInputs = { ...inputs };
        try {
          if (newUnitSystem === 'metric') {
            // Convert from imperial to metric
            newInputs.length = (inputs.length * FEET_TO_METERS).toFixed(2);
            newInputs.width = (inputs.width * FEET_TO_METERS).toFixed(2);
            newInputs.height = (inputs.height * FEET_TO_METERS).toFixed(2);
            newInputs.sandInletTemp = fahrenheitToCelsius(inputs.sandInletTemp);
            newInputs.sandDischargeTemp = fahrenheitToCelsius(inputs.sandDischargeTemp);
            newInputs.stoneInletTemp = fahrenheitToCelsius(inputs.stoneInletTemp);
            newInputs.stoneDischargeTemp = fahrenheitToCelsius(inputs.stoneDischargeTemp);
          } else {
            // Convert from metric to imperial
            newInputs.length = (inputs.length * METERS_TO_FEET).toFixed(2);
            newInputs.width = (inputs.width * METERS_TO_FEET).toFixed(2);
            newInputs.height = (inputs.height * METERS_TO_FEET).toFixed(2);
            newInputs.sandInletTemp = celsiusToFahrenheit(inputs.sandInletTemp);
            newInputs.sandDischargeTemp = celsiusToFahrenheit(inputs.sandDischargeTemp);
            newInputs.stoneInletTemp = celsiusToFahrenheit(inputs.stoneInletTemp);
            newInputs.stoneDischargeTemp = celsiusToFahrenheit(inputs.stoneDischargeTemp);
          }
          setInputs(newInputs);
          setUnitSystem(newUnitSystem);
          setResults(null); // Clear results to avoid confusion
        } catch (error) {
          console.error('Unit system conversion error:', error);
        }
      };

      // Calculating volumes and heat times
      const calculateHeatTimes = () => {
        try {
          // Validating all inputs
          const newErrors = {};
          Object.keys(inputs).forEach((key) => {
            if (key !== 'customer') { // Skip customer validation
              const error = validateInput(key, inputs[key]);
              if (error) newErrors[key] = error;
            }
          });

          if (Object.keys(newErrors).length > 0) {
            setErrors(newErrors);
            setResults(null);
            return;
          }

          // Convert dimensions to feet for calculations if in metric
          const lengthInFeet = unitSystem === 'metric' ? parseFloat(inputs.length) * METERS_TO_FEET : parseFloat(inputs.length);
          const widthInFeet = unitSystem === 'metric' ? parseFloat(inputs.width) * METERS_TO_FEET : parseFloat(inputs.width);
          const heightInFeet = unitSystem === 'metric' ? parseFloat(inputs.height) * METERS_TO_FEET : parseFloat(inputs.height);

          // Calculating cubed and sloped section dimensions
          const cubedLength = lengthInFeet < 6 ? 0 : lengthInFeet - 6;
          const cubedWidth = widthInFeet;
          const cubedHeight = heightInFeet;
          const slopedLength = lengthInFeet < 6 ? lengthInFeet : 6;
          const slopedWidth = widthInFeet;
          const slopedHeight = heightInFeet;

          // Calculating volumes (in cubic feet)
          const cubedVolume = cubedLength * cubedWidth * cubedHeight;
          // Sloped volume uses triangular cross-sectional area: (length * height / 2) * width
          const slopedVolume = (slopedLength * slopedHeight / 2) * slopedWidth;
          const totalCuFt = cubedVolume + slopedVolume;

          // Converting volumes to display units
          const volumeUnit = unitSystem === 'imperial' ? 'ft³' : 'm³';
          const volumeFactor = unitSystem === 'imperial' ? 1 : CUBIC_FEET_TO_CUBIC_METERS;
          const cubedVolumeConverted = (cubedVolume * volumeFactor).toFixed(2);
          const slopedVolumeConverted = (slopedVolume * volumeFactor).toFixed(2);

          // Convert temperatures to °F for calculations if in metric
          const sandInletTemp = unitSystem === 'metric' ? parseFloat(celsiusToFahrenheit(inputs.sandInletTemp)) : parseFloat(inputs.sandInletTemp);
          const sandDischargeTemp = unitSystem === 'metric' ? parseFloat(celsiusToFahrenheit(inputs.sandDischargeTemp)) : parseFloat(inputs.sandDischargeTemp);
          const stoneInletTemp = unitSystem === 'metric' ? parseFloat(celsiusToFahrenheit(inputs.stoneInletTemp)) : parseFloat(inputs.stoneInletTemp);
          const stoneDischargeTemp = unitSystem === 'metric' ? parseFloat(celsiusToFahrenheit(inputs.stoneDischargeTemp)) : parseFloat(inputs.stoneDischargeTemp);

          // Defining materials with temperature differences
          const materials = materialProperties.map((prop) => ({
            name: prop.name,
            weight: prop.weight,
            specificHeat: prop.specificHeat,
            tempDiff: prop.key === 'sand'
              ? sandDischargeTemp - sandInletTemp
              : stoneDischargeTemp - stoneInletTemp
          }));

          // Calculating heat times
          const heatTimes = materials.map((material) => {
            const totalWeight = totalCuFt * material.weight;
            const btuRequired = totalWeight * material.specificHeat * material.tempDiff;
            const times = steamGenerators.map((gen) => {
              const timeHours = btuRequired / gen.btu;
              const timeWithSafety = timeHours * 1.3; // 30% safety margin
              return isNaN(timeWithSafety) ? 'N/A' : timeWithSafety.toFixed(2);
            });
            return { material: material.name, times };
          });

          setResults({
            heatTimes,
            cubed: { 
              length: (unitSystem === 'metric' ? cubedLength * FEET_TO_METERS : cubedLength).toFixed(2), 
              width: (unitSystem === 'metric' ? cubedWidth * FEET_TO_METERS : cubedWidth).toFixed(2), 
              height: (unitSystem === 'metric' ? cubedHeight * FEET_TO_METERS : cubedHeight).toFixed(2), 
              volume: cubedVolumeConverted, 
              unit: volumeUnit 
            },
            sloped: { 
              length: (unitSystem === 'metric' ? slopedLength * FEET_TO_METERS : slopedLength).toFixed(2), 
              width: (unitSystem === 'metric' ? slopedWidth * FEET_TO_METERS : slopedWidth).toFixed(2), 
              height: (unitSystem === 'metric' ? slopedHeight * FEET_TO_METERS : slopedHeight).toFixed(2), 
              volume: slopedVolumeConverted, 
              unit: volumeUnit 
            },
            customer: inputs.customer // Store customer input
          });
          setErrors({});
        } catch (error) {
          console.error('Calculation error:', error);
          setErrors({ general: 'An error occurred during calculation. Please check inputs and try again.' });
          setResults(null);
        }
      };

      // Function to download results as PDF
      const downloadPDF = () => {
        if (!results) return;

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const margin = 10;
        const pageWidth = doc.internal.pageSize.getWidth();
        let y = 10;

        // Color definitions (approximating Tailwind colors)
        const colors = {
          blue50: [219, 234, 254], // bg-blue-50
          green50: [220, 252, 231], // bg-green-50
          yellow50: [254, 240, 138], // bg-yellow-50
          teal50: [204, 251, 241], // bg-teal-50
          gray700: [55, 65, 81], // text-gray-700
          indigo600: [79, 70, 229] // bg-indigo-600
        };

        // Helper function to draw a section box
        const drawSectionBox = (startY, height, color, title, titleColor) => {
          doc.setFillColor(...color);
          doc.setDrawColor(...colors.gray700);
          doc.roundedRect(margin, startY, pageWidth - 2 * margin, height, 3, 3, 'FD');
          doc.setFontSize(14);
          doc.setFont('helvetica', 'bold');
          doc.setTextColor(...titleColor);
          doc.text(title, margin + 5, startY + 7);
          doc.setFont('helvetica', 'normal');
          doc.setTextColor(...colors.gray700);
          return startY + height; // Return the bottom position of the box
        };

        // Company Information
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...colors.gray700);
        doc.text('Steam Engineering - A Division of Vortomech Industries Inc.', margin, y);
        y += 6;
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text('T: +1(647)749-4064', margin, y);
        y += 5;
        doc.text('E: contactus@vortomech.com', margin, y);
        y += 8;

        // Date, time, and version
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const dateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        const calculatorVersion = "Version 20";

        // Title
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...colors.gray700);
        doc.text('Concrete Pad Heating Calculator Results', margin, y);
        y += 7;

        // Date, Time, and Version
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated on: ${dateTime}`, margin, y);
        y += 5;
        doc.text(`Calculator: ${calculatorVersion}`, margin, y);
        y += 8;

        // Customer Information
        if (results.customer) {
          y = drawSectionBox(y, 20, colors.blue50, 'Customer Information', colors.indigo600);
          doc.setFontSize(10);
          doc.text(`Customer: ${results.customer}`, margin + 5, y - 8);
          y += 2; // Small gap after the box
        }

        // Unit System
        y = drawSectionBox(y, 20, colors.blue50, 'Unit System', colors.indigo600);
        doc.setFontSize(10);
        doc.text(`Unit System: ${unitSystem === 'imperial' ? 'Imperial (ft, °F)' : 'Metric (m, °C)'}`, margin + 5, y - 8);
        y += 2; // Small gap after the box

        // Inputs
        y = drawSectionBox(y, 50, colors.green50, 'Input Parameters', colors.indigo600);
        doc.setFontSize(10);
        let inputY = y - 38; // Start inside the box, below the title
        doc.text(`Length: ${inputs.length} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 5, inputY);
        inputY += 5;
        doc.text(`Width: ${inputs.width} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 5, inputY);
        inputY += 5;
        doc.text(`Height: ${inputs.height} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 5, inputY);
        inputY += 5;
        doc.text(`Sand Inlet Temp: ${inputs.sandInletTemp} ${unitSystem === 'imperial' ? '°F' : '°C'}`, margin + 5, inputY);
        inputY += 5;
        doc.text(`Sand Discharge Temp: ${inputs.sandDischargeTemp} ${unitSystem === 'imperial' ? '°F' : '°C'}`, margin + 5, inputY);
        inputY += 5;
        doc.text(`Stone Inlet Temp: ${inputs.stoneInletTemp} ${unitSystem === 'imperial' ? '°F' : '°C'}`, margin + 5, inputY);
        inputY += 5;
        doc.text(`Stone Discharge Temp: ${inputs.stoneDischargeTemp} ${unitSystem === 'imperial' ? '°F' : '°C'}`, margin + 5, inputY);
        y += 2; // Small gap after the box

        // Calculated Sections
        const calcSectionsHeight = 12 + (4 * 5 + 7) * 2 + 10; // 69 units
        const calcStartY = y;
        y = drawSectionBox(y, calcSectionsHeight, colors.yellow50, 'Calculated Sections', colors.indigo600);
        doc.setFontSize(10);
        let calcY = calcStartY + 12;
        doc.setFont('helvetica', 'bold');
        doc.text('Cubed Section:', margin + 5, calcY);
        doc.setFont('helvetica', 'normal');
        calcY += 5;
        doc.text(`Length: ${results.cubed.length} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 10, calcY);
        calcY += 5;
        doc.text(`Width: ${results.cubed.width} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 10, calcY);
        calcY += 5;
        doc.text(`Height: ${results.cubed.height} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 10, calcY);
        calcY += 5;
        doc.text(`Volume: ${results.cubed.volume} ${results.cubed.unit}`, margin + 10, calcY);
        calcY += 7;
        doc.setFont('helvetica', 'bold');
        doc.text('Sloped Section:', margin + 5, calcY);
        doc.setFont('helvetica', 'normal');
        calcY += 5;
        doc.text(`Length: ${results.sloped.length} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 10, calcY);
        calcY += 5;
        doc.text(`Width: ${results.sloped.width} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 10, calcY);
        calcY += 5;
        doc.text(`Height: ${results.sloped.height} ${unitSystem === 'imperial' ? 'ft' : 'm'}`, margin + 10, calcY);
        calcY += 5;
        doc.text(`Volume: ${results.sloped.volume} ${results.cubed.unit}`, margin + 10, calcY);
        y += 10; // Add a gap after the box to prevent overlap

        // Heat-Up Times
        const tableStartY = y;
        y = drawSectionBox(y, 40, colors.teal50, 'Heat-Up Times (Hours)', colors.indigo600);
        doc.setFontSize(10);
        const headers = ['Material', 'ST102', 'ST302', 'ST502', 'ST602'];
        const tableData = results.heatTimes.map(row => [row.material, ...row.times]);
        doc.autoTable({
          startY: tableStartY + 12,
          head: [headers],
          body: tableData,
          theme: 'grid',
          styles: { fontSize: 8, font: 'helvetica', textColor: colors.gray700 },
          headStyles: { fillColor: colors.indigo600, textColor: [255, 255, 255] },
          margin: { left: margin, right: margin }
        });

        // Generate filename with date and time
        const filename = `Concrete_Pad_Heating_Results_${year}-${month}-${day}_${hours}-${minutes}-${seconds}.pdf`;

        // Save the PDF
        doc.save(filename);
      };

      // Rendering input field
      const renderInput = (label, name, value, type = 'number') => (
        <div className="mb-2">
          <label className="block text-xs font-medium text-gray-700">{label}</label>
          <input
            type={type}
            name={name}
            value={value}
            onChange={handleInputChange}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
            step={type === 'number' ? 'any' : undefined}
          />
          {errors[name] && <p className="text-red-500 text-xs mt-1">{errors[name]}</p>}
        </div>
      );

      // Rendering form
      return (
        <div className="max-w-3xl w-full bg-white p-4 rounded-lg shadow-lg">
          <h1 className="text-xl font-bold mb-4 text-center">Concrete Pad Heating Calculator</h1>
          {errors.general && <p className="text-red-500 text-xs mb-4 text-center">{errors.general}</p>}

          {/* Customer input */}
          <div className="mb-4 bg-blue-50 p-4 rounded-lg">
            <h2 className="text-md font-semibold mb-2">Customer Information</h2>
            {renderInput('Customer', 'customer', inputs.customer, 'text')}
          </div>

          {/* Unit system selection */}
          <div className="mb-4 bg-blue-50 p-4 rounded-lg">
            <h2 className="text-md font-semibold mb-2">Unit System</h2>
            <div className="flex space-x-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  value="imperial"
                  checked={unitSystem === 'imperial'}
                  onChange={() => handleUnitSystemChange('imperial')}
                  className="mr-2"
                />
                <span className="text-sm">Imperial (ft, °F)</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  value="metric"
                  checked={unitSystem === 'metric'}
                  onChange={() => handleUnitSystemChange('metric')}
                  className="mr-2"
                />
                <span className="text-sm">Metric (m, °C)</span>
              </label>
            </div>
          </div>

          {/* Rendering pad dimensions */}
          <div className="mb-4 bg-green-50 p-4 rounded-lg">
            <h2 className="text-md font-semibold mb-2 flex items-center">
              Pad Dimensions
              <Tooltip text="Enter the overall dimensions of the pad based on the area that is expected to be occupied. We are assuming a three-sided bunker with block or precast walls." />
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {renderInput(`Length (${unitSystem === 'imperial' ? 'FT' : 'M'})`, 'length', inputs.length)}
              {renderInput(`Width (${unitSystem === 'imperial' ? 'FT' : 'M'})`, 'width', inputs.width)}
              {renderInput(`Height (${unitSystem === 'imperial' ? 'FT' : 'M'})`, 'height', inputs.height)}
            </div>
          </div>

          {/* Rendering calculated dimensions */}
          {results && (
            <div className="mb-4 bg-yellow-50 p-4 rounded-lg">
              <h2 className="text-md font-semibold mb-2">Calculated Sections</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <h3 className="text-sm font-medium mb-1">Cubed Section</h3>
                  <p className="text-xs text-gray-600">Length: {results.cubed.length} {unitSystem === 'imperial' ? 'FT' : 'M'}</p>
                  <p className="text-xs text-gray-600">Width: {results.cubed.width} {unitSystem === 'imperial' ? 'FT' : 'M'}</p>
                  <p className="text-xs text-gray-600">Height: {results.cubed.height} {unitSystem === 'imperial' ? 'FT' : 'M'}</p>
                  <p className="text-xs text-gray-600">Volume: {results.cubed.volume} {results.cubed.unit}</p>
                </div>
                <div>
                  <h3 className="text-sm font-medium mb-1">Sloped Section</h3>
                  <p className="text-xs text-gray-600">Length: {results.sloped.length} {unitSystem === 'imperial' ? 'FT' : 'M'}</p>
                  <p className="text-xs text-gray-600">Width: {results.sloped.width} {unitSystem === 'imperial' ? 'FT' : 'M'}</p>
                  <p className="text-xs text-gray-600">Height: {results.sloped.height} {unitSystem === 'imperial' ? 'FT' : 'M'}</p>
                  <p className="text-xs text-gray-600">Volume: {results.sloped.volume} {results.cubed.unit}</p>
                </div>
              </div>
            </div>
          )}

          {/* Rendering material properties reference table */}
          <div className="mb-4 bg-purple-50 p-4 rounded-lg">
            <h2 className="text-md font-semibold mb-2">Material Properties (Reference)</h2>
            <div className="overflow-x-auto">
              <table className="min-w-full bg-white border text-xs">
                <thead>
                  <tr>
                    <th className="py-1 px-2 border">Material</th>
                    <th className="py-1 px-2 border">Weight ({unitSystem === 'imperial' ? 'lb/ft³' : 'kg/m³'})</th>
                    <th className="py-1 px-2 border">Specific Heat ({unitSystem === 'imperial' ? 'BTU/lb·°F' : 'kJ/kg·°C'})</th>
                  </tr>
                </thead>
                <tbody>
                  {materialProperties.map((prop, index) => (
                    <tr key={index} className="text-center">
                      <td className="py-1 px-2 border">{prop.name}</td>
                      <td className="py-1 px-2 border">
                        {unitSystem === 'imperial' ? prop.weight : (prop.weight * LB_PER_CUFT_TO_KG_PER_CUM).toFixed(1)}
                      </td>
                      <td className="py-1 px-2 border">
                        {unitSystem === 'imperial' ? prop.specificHeat : (prop.specificHeat * BTU_PER_LB_F_TO_KJ_PER_KG_C).toFixed(3)}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          {/* Rendering differential temperatures */}
          <div className="mb-4 bg-pink-50 p-4 rounded-lg">
            <h2 className="text-md font-semibold mb-2 flex items-center">
              Differential Temperatures
              <Tooltip text="Default values for inlet temperatures is -10C (14F), Discharge temperature for Sand is 48C (118.4F), Discharge temperature for Stone & Limestone is 10C (50F)." />
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <h3 className="text-sm font-medium mb-1">Sand 5mm</h3>
                {renderInput(`Inlet Temp (${unitSystem === 'imperial' ? '°F' : '°C'})`, 'sandInletTemp', inputs.sandInletTemp)}
                {renderInput(`Discharge Temp (${unitSystem === 'imperial' ? '°F' : '°C'})`, 'sandDischargeTemp', inputs.sandDischargeTemp)}
              </div>
              <div>
                <h3 className="text-sm font-medium mb-1">Stone & Limestone</h3>
                {renderInput(`Inlet Temp (${unitSystem === 'imperial' ? '°F' : '°C'})`, 'stoneInletTemp', inputs.stoneInletTemp)}
                {renderInput(`Discharge Temp (${unitSystem === 'imperial' ? '°F' : '°C'})`, 'stoneDischargeTemp', inputs.stoneDischargeTemp)}
              </div>
            </div>
          </div>

          {/* Rendering steam generator reference table */}
          <div className="mb-4 bg-indigo-50 p-4 rounded-lg">
            <h2 className="text-md font-semibold mb-2">Steam Generator Power (Reference)</h2>
            <div className="overflow-x-auto">
              <table className="min-w-full bg-white border text-xs">
                <thead>
                  <tr>
                    <th className="py-1 px-2 border">Generator</th>
                    <th className="py-1 px-2 border">Power ({unitSystem === 'imperial' ? 'BTU/HR' : 'kW'})</th>
                  </tr>
                </thead>
                <tbody>
                  {steamGenerators.map((gen, index) => (
                    <tr key={index} className="text-center">
                      <td className="py-1 px-2 border">{gen.name}</td>
                      <td className="py-1 px-2 border">
                        {unitSystem === 'imperial' ? gen.btu.toLocaleString() : (gen.btu * BTU_PER_HR_TO_KW).toFixed(2)}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          {/* Rendering calculate and download buttons */}
          <div className="text-center mb-4 flex justify-center space-x-4">
            <button
              onClick={calculateHeatTimes}
              className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 text-sm"
            >
              Calculate Heat Times
            </button>
            {results && (
              <button
                onClick={downloadPDF}
                className="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 text-sm"
              >
                Download PDF
              </button>
            )}
          </div>

          {/* Rendering results table */}
          {results && (
            <div className="mt-4 bg-teal-50 p-4 rounded-lg">
              <h2 className="text-md font-semibold mb-2">Heat-Up Times (Hours)</h2>
              <div className="overflow-x-auto">
                <table className="min-w-full bg-white border text-xs">
                  <thead>
                    <tr>
                      <th className="py-1 px-2 border">Material</th>
                      <th className="py-1 px-2 border">ST102</th>
                      <th className="py-1 px-2 border">ST302</th>
                      <th className="py-1 px-2 border">ST502</th>
                      <th className="py-1 px-2 border">ST602</th>
                    </tr>
                  </thead>
                  <tbody>
                    {results.heatTimes.map((result, index) => (
                      <tr key={index} className="text-center">
                        <td className="py-1 px-2 border">{result.material}</td>
                        {result.times.map((time, i) => (
                          <td key={i} className="py-1 px-2 border">{time}</td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      );
    };

    // Rendering the app
    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<PadHeatingCalculator />);
    } catch (error) {
      console.error('Rendering error:', error);
    }
  </script>
</body>
</html>